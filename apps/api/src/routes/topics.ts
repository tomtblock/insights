/**
 * Topics API Routes
 * Section 5.8 - GET/POST /api/topics
 * 
 * Topics are generated by the LLM scanner and go through governance workflow.
 */

import { Router } from 'express';
import { db } from '../server';
import { TopicPackSchema, TopicSchema } from '@arb/schemas';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';

export const topicsRouter = Router();

// Query params schema
const TopicsQuerySchema = z.object({
  status: z.enum(['proposed', 'approved', 'rejected', 'paused', 'archived']).optional(),
  q: z.string().optional(),
  page: z.coerce.number().int().min(0).default(0),
  page_size: z.coerce.number().int().min(1).max(100).default(50),
});

// GET /api/topics - List topics with filters
topicsRouter.get('/', async (req, res) => {
  try {
    const params = TopicsQuerySchema.parse(req.query);
    const { status, q, page, page_size } = params;

    let whereClause = 'WHERE 1=1';
    const values: any[] = [];
    let paramIndex = 1;

    if (status) {
      whereClause += ` AND status = $${paramIndex}`;
      values.push(status);
      paramIndex++;
    }
    if (q) {
      whereClause += ` AND label ILIKE $${paramIndex}`;
      values.push(`%${q}%`);
      paramIndex++;
    }

    // Get total count
    const countResult = await db.query(
      `SELECT COUNT(*) FROM topics ${whereClause}`,
      values
    );
    const total = parseInt(countResult.rows[0].count);

    // Get page of results with signal count
    values.push(page_size, page * page_size);
    const dataResult = await db.query(
      `SELECT t.*,
              (SELECT COUNT(*) FROM topic_signals ts WHERE ts.topic_id = t.topic_id) as signal_count,
              (SELECT MAX(ts) FROM topic_signals ts WHERE ts.topic_id = t.topic_id) as last_signal_ts,
              (SELECT COUNT(*) FROM topic_market_links tml WHERE tml.topic_id = t.topic_id) as market_count
       FROM topics t
       ${whereClause}
       ORDER BY 
         CASE WHEN status = 'proposed' THEN 0
              WHEN status = 'approved' THEN 1
              ELSE 2 END,
         created_at DESC
       LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`,
      values
    );

    res.json({
      success: true,
      data: dataResult.rows,
      pagination: {
        page,
        page_size,
        total,
        has_more: (page + 1) * page_size < total,
      },
      ts: Date.now(),
    });
  } catch (error) {
    console.error('GET /api/topics error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      ts: Date.now(),
    });
  }
});

// GET /api/topics/:id - Get single topic
topicsRouter.get('/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await db.query(
      `SELECT t.*,
              (SELECT jsonb_agg(
                jsonb_build_object(
                  'venue', tml.venue,
                  'outcome_id_native', tml.outcome_id_native,
                  'confidence', tml.confidence,
                  'market_title', m.title
                )
              ) FROM topic_market_links tml
               LEFT JOIN pm_market_outcomes m ON m.venue = tml.venue AND m.outcome_id_native = tml.outcome_id_native
               WHERE tml.topic_id = t.topic_id
              ) as linked_markets
       FROM topics t
       WHERE topic_id = $1`,
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Topic not found',
        ts: Date.now(),
      });
    }

    res.json({
      success: true,
      data: result.rows[0],
      ts: Date.now(),
    });
  } catch (error) {
    console.error('GET /api/topics/:id error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      ts: Date.now(),
    });
  }
});

// POST /api/topics/scan - Trigger LLM topic scan
topicsRouter.post('/scan', async (req, res) => {
  try {
    const { market_ids } = req.body;

    // If no market_ids provided, select candidate markets
    let candidateMarkets: any[];
    if (market_ids && market_ids.length > 0) {
      const result = await db.query(
        `SELECT * FROM pm_market_outcomes 
         WHERE id = ANY($1::uuid[]) AND status = 'open'`,
        [market_ids]
      );
      candidateMarkets = result.rows;
    } else {
      // Select candidate markets (as per section 10.2)
      const result = await db.query(
        `SELECT * FROM pm_market_outcomes
         WHERE status = 'open'
           AND (resolve_ts IS NULL OR resolve_ts > NOW() + INTERVAL '180 days')
         ORDER BY updated_at DESC
         LIMIT 50`
      );
      candidateMarkets = result.rows;
    }

    if (candidateMarkets.length === 0) {
      return res.json({
        success: true,
        data: {
          status: 'NO_CANDIDATES',
          message: 'No candidate markets found for scanning',
          markets_checked: 0,
        },
        ts: Date.now(),
      });
    }

    // Record LLM run (actual LLM call would be done by topics-llm service)
    const runId = uuidv4();
    const promptHash = Buffer.from(JSON.stringify(candidateMarkets.map(m => m.id))).toString('base64').substring(0, 32);

    await db.query(
      `INSERT INTO llm_topic_runs (run_id, model, input_market_ids, prompt_hash, response_json, validation_passed, errors)
       VALUES ($1, 'gpt-4o', $2, $3, '{"status": "pending"}', false, '[]')`,
      [runId, JSON.stringify(candidateMarkets.map(m => m.id)), promptHash]
    );

    res.json({
      success: true,
      data: {
        run_id: runId,
        status: 'QUEUED',
        markets_submitted: candidateMarkets.length,
        message: 'Topic scan queued - results will appear in /api/topics when ready',
      },
      ts: Date.now(),
    });
  } catch (error) {
    console.error('POST /api/topics/scan error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      ts: Date.now(),
    });
  }
});

// POST /api/topics/:id/approve - Approve topic for monitoring
topicsRouter.post('/:id/approve', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await db.query(
      `UPDATE topics SET status = 'approved', updated_at = NOW()
       WHERE topic_id = $1 AND status = 'proposed'
       RETURNING *`,
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Topic not found or not in proposed status',
        ts: Date.now(),
      });
    }

    res.json({
      success: true,
      data: result.rows[0],
      ts: Date.now(),
    });
  } catch (error) {
    console.error('POST /api/topics/:id/approve error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      ts: Date.now(),
    });
  }
});

// POST /api/topics/:id/reject - Reject topic
topicsRouter.post('/:id/reject', async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body;

    const result = await db.query(
      `UPDATE topics SET status = 'rejected', rationale = COALESCE(rationale, '') || E'\n[REJECTED] ' || $2, updated_at = NOW()
       WHERE topic_id = $1 AND status = 'proposed'
       RETURNING *`,
      [id, reason || 'No reason provided']
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Topic not found or not in proposed status',
        ts: Date.now(),
      });
    }

    res.json({
      success: true,
      data: result.rows[0],
      ts: Date.now(),
    });
  } catch (error) {
    console.error('POST /api/topics/:id/reject error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      ts: Date.now(),
    });
  }
});

// POST /api/topics/:id/pause - Pause topic monitoring
topicsRouter.post('/:id/pause', async (req, res) => {
  try {
    const { id } = req.params;

    const result = await db.query(
      `UPDATE topics SET status = 'paused', updated_at = NOW()
       WHERE topic_id = $1 AND status = 'approved'
       RETURNING *`,
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Topic not found or not in approved status',
        ts: Date.now(),
      });
    }

    res.json({
      success: true,
      data: result.rows[0],
      ts: Date.now(),
    });
  } catch (error) {
    console.error('POST /api/topics/:id/pause error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      ts: Date.now(),
    });
  }
});

// GET /api/topics/:id/signals - Get signals for topic
topicsRouter.get('/:id/signals', async (req, res) => {
  try {
    const { id } = req.params;
    const page = parseInt(req.query.page as string) || 0;
    const page_size = Math.min(parseInt(req.query.page_size as string) || 50, 100);

    const countResult = await db.query(
      `SELECT COUNT(*) FROM topic_signals WHERE topic_id = $1`,
      [id]
    );
    const total = parseInt(countResult.rows[0].count);

    const dataResult = await db.query(
      `SELECT ts.*, 
              e.title as derived_event_title
       FROM topic_signals ts
       LEFT JOIN events_current e ON e.event_id = ts.derived_event_id
       WHERE ts.topic_id = $1
       ORDER BY ts.ts DESC
       LIMIT $2 OFFSET $3`,
      [id, page_size, page * page_size]
    );

    res.json({
      success: true,
      data: dataResult.rows,
      pagination: {
        page,
        page_size,
        total,
        has_more: (page + 1) * page_size < total,
      },
      ts: Date.now(),
    });
  } catch (error) {
    console.error('GET /api/topics/:id/signals error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      ts: Date.now(),
    });
  }
});

// POST /api/topics/bulk-approve - Approve all topics for a market
topicsRouter.post('/bulk-approve', async (req, res) => {
  try {
    const { market_id, topic_ids } = req.body;

    if (!topic_ids || !Array.isArray(topic_ids) || topic_ids.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'topic_ids array is required',
        ts: Date.now(),
      });
    }

    const result = await db.query(
      `UPDATE topics SET status = 'approved', updated_at = NOW()
       WHERE topic_id = ANY($1::uuid[]) AND status = 'proposed'
       RETURNING *`,
      [topic_ids]
    );

    res.json({
      success: true,
      data: {
        approved_count: result.rowCount,
        approved_topics: result.rows,
      },
      ts: Date.now(),
    });
  } catch (error) {
    console.error('POST /api/topics/bulk-approve error:', error);
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      ts: Date.now(),
    });
  }
});

